# Project Euler solution implementations
from __future__ import division
import cProfile
import math
import collections


def sieve(limit):
    return sieve_of_eratosthenes(limit)


def prod(iterable):
    from operator import mul
    return reduce(mul, iterable, 1)


def sieve_of_eratosthenes(limit):
    # Uses Sieve of Eratosthenes to get a list of primes up to limit
    # Pretty slow for larger limits, seems like the union is the problem?

    # from http://code.jasonbhill.com/python/project-euler-problem-7/
    # apparently printing is really slow

    # generate a list of Trues before starting the sieve
    primes = [True] * limit

    # 0 and 1 are not primes
    primes[0], primes[1] = [None] * 2

    for i, v in enumerate(primes):
        if v is True:
            # all multiples of that number are not prime
            primes[i*2::i] = [False] * (((limit - 1) // i) - 1)

    return [k for k, v in enumerate(primes) if v is True]


def iterable_sieve():
    """
    Iterable version of the sieve
    """
    excluded = []
    x = 2
    while True:
        prime = True
        for y in excluded:
            if x % y == 0:
                prime = False
                break
        if prime is True:
            yield x
        excluded.append(x)
        x += 1


def nth_prime(n):
    """
    Returns the nth prime
    """
    limit = n
    sieve = iterable_sieve()
    i = 0
    while i < limit:
        prime = sieve.next()
        i += 1
    return prime


def is_prime(num):
    """
    Check if a number is prime
    """
    if num % 2 == 0:
        return False

    fac = 3
    while fac < num**0.5 + 1:
        if num % fac == 0:
            return False
        fac += 2

    return True


def is_palindromic(num):
    """
    Checks if a number reads both the same both ways
    """
    if isinstance(num, collections.deque):
        remaining = num
    else:
        remaining = collections.deque(str(num))

    if len(remaining) in [0, 1]:
        return True
    else:
        left = remaining.popleft()
        right = remaining.pop()
        if left == right:
            return is_palindromic(remaining)
        else:
            return False


def gcd(*numbers):
    """
    https://gist.github.com/endolith/114336
    """
    from fractions import gcd
    return reduce(gcd, numbers)


def lcm(*numbers):
    """
    Returns the least common multiple of two numbers
    """
    return reduce(lambda x, y: (x * y) / gcd(x, y), numbers, 1)


class Solution(object):
    def run(self, **kwargs):
        print("Running {}".format(self.__class__.__name__))
        cProfile.runctx('self.solve(**kwargs)', globals(), locals())
        print("The solution is {}".format(self.answer))

    def solve(self):
        raise NotImplemented


class Solution1(Solution):
    def solve(self, **kwargs):
        # If we list all the natural numbers below 10 that are multiples of 3 or 5,
        # we get 3, 5, 6 and 9. The sum of these multiples is 23.

        # Find the sum of all the multiples of 3 or 5 below 1000.
        mult = [3 * x for x in range(1, (1000 / 3) + 1)]
        mult.extend([5 * x for x in range(1, 1000 / 5)])
        nums = set(mult)
        self.answer = sum(nums)

#Solution1().run()


class Solution2(Solution):
    def solve(self, **kwargs):
        # Each new term in the Fibonacci sequence is generated by adding the previous two terms.
        # By starting with 1 and 2, the first 10 terms will be:

#            1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

        # By considering the terms in the Fibonacci sequence whose values do not exceed four million,
        # find the sum of the even-valued terms.
        limit = kwargs['limit']
        fib = [1, 2]
        while fib[len(fib) - 1] < limit:
            fib.append(fib[len(fib) - 1] + fib[len(fib) - 2])
        res = [x for x in fib if x % 2 == 0]
        self.answer = sum(res)

#Solution2().run(limit=4000000)


class Solution3(Solution):
    def solve(self, **kwargs):
        limit = kwargs['limit']
        primes = []
        for x in range(2, int(math.ceil(math.sqrt(limit)))):
            if is_prime(x):
                if limit % x == 0:
                    primes.append(x)
                    self.answer = x
        print(primes)
        return primes

#Solution3().run(limit=600851475143)


class Solution4(Solution):
    def solve(self, **kwargs):
        three_digit = range(900, 1000)
        nums = set()
        for x in three_digit:
            for y in three_digit:
                nums.add(x * y)
        ans = 0
        for x in nums:
            if is_palindromic(x) and x > ans:
                ans = x
        self.answer = ans

#Solution4().run()


class Solution5(Solution):
    def solve(self, **kwargs):
        self.answer = lcm(*range(1, 21))

#Solution5().run()


class Solution6(Solution):
    def sum_of_squares(self, *nums):
        return sum([x ** 2 for x in nums])

    def square_of_sum(self, *nums):
        return sum(nums) ** 2

    def solve(self, **kwargs):
        nums = range(1, 101)
        self.answer = self.square_of_sum(*nums) - self.sum_of_squares(*nums)

#Solution6().run()


class Solution7(Solution):
    def solve(self, limit=10001, **kwargs):
        self.answer = nth_prime(limit)

#Solution7().run()


class Solution8(Solution):
    def solve(self):

        num = 7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450
        digits = [int(x) for x in str(num)]
        maximum = 0
        while len(digits) > 4:
            maximum = max(maximum, prod(digits[0:5]))
            digits.pop(0)

        self.answer = maximum

#Solution8().run()


class Solution9(Solution):
    #A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,

    #a2 + b2 = c2
    #For example, 32 + 42 = 9 + 16 = 25 = 52.

    #There exists exactly one Pythagorean triplet for which a + b + c = 1000.
    #Find the product abc.

    # a < b < c < 999
    # a + b + c = 1000
    # a2 + b2 = c2
    #
    # c = sqrt(a2 + b2) = 1000 - a - b
    # a + b = 1000 - c
    # c must be a perfect square as well, since it is the square root of two
    # integers
    # a + b + sqrt(a2 + b2) = 1000
    def is_perfect_square(self, num):
        return math.sqrt(num).is_integer()

    def pythagorean_triple(self, m, n):
        a = (m ** 2) - (n ** 2)
        b = 2 * m * n
        c = (m ** 2) + (n ** 2)
        return (a, b, c)

    def solve(self):
        self.answer = None
        # find all perfect squares less than 999
#        cs = [x for x in range(1, 1000) if self.is_perfect_square(x)]
        m = 2
        while self.answer is None:
            for n in range(1, m):
                triple = self.pythagorean_triple(m, n)
                print(triple)
                if sum(triple) == 1000:
                    self.answer = prod(triple)
            m += 1


#Solution9().run()

class Solution10(Solution):
    def solve(self):
        primes = sieve_of_eratosthenes(2000001)
        self.answer = sum(primes)

#Solution10().run()

class Solution11(Solution):
    def solve(self):
        matrix_string = "8 2 22 97 38 15 0 40 0 75 4 5 7 78 52 12 50 77 91 8; 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 4 56 62 0; 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 3 49 13 36 65; 52 70 95 23 4 60 11 42 69 24 68 56 1 32 56 71 37 2 36 91; 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80; 24 47 32 60 99 3 45 2 44 75 33 53 78 36 84 20 35 17 12 50; 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70; 67 26 20 68 2 62 12 20 95 63 94 39 63 8 40 91 66 49 94 21; 24 55 58 5 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72; 21 36 23 9 75 0 76 44 20 45 35 14 0 61 33 97 34 31 33 95; 78 17 53 28 22 75 31 67 15 94 3 80 4 62 16 14 9 53 56 92; 16 39 5 42 96 35 31 47 55 58 88 24 0 17 54 24 36 29 85 57; 86 56 0 48 35 71 89 7 5 44 44 37 44 60 21 58 51 54 17 58; 19 80 81 68 5 94 47 69 28 73 92 13 86 52 17 77 4 89 55 40; 4 52 8 83 97 35 99 16 7 97 57 32 16 26 26 79 33 27 98 66; 88 36 68 87 57 62 20 72 3 46 33 67 46 55 12 32 63 93 53 69; 4 42 16 73 38 25 39 11 24 94 72 18 8 46 29 32 40 62 76 36; 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 4 36 16; 20 73 35 29 78 31 90 1 74 31 49 71 48 86 81 16 23 57 5 54; 1 70 54 71 83 51 54 69 16 92 33 48 61 43 52 1 89 19 67 48"
        import numpy
        matrix = numpy.matrix(matrix_string)
        maxes = []

        # horizontal products
        h_prods = []
        for y in range(0, 20):
            for x in range(0, 16):
                h_prods.append(matrix[y, x:x+4].sum())

        maxes.append(max(h_prods))

        # vertical products
        v_prods = []
        for x in range(0, 20):
            for y in range(0, 16):
                v_prods.append(matrix[y:y+4, x].sum())
        maxes.append(max(v_prods))

        # \ diagonal products
        d_prods = []
        for x in range(0, 16):
            for y in range(0, 16):
                d_prods.append(matrix[x,y] * matrix[x+1, y+1] * matrix[x+2, y+2] * matrix[x+3, y+3])
        maxes.append(max(d_prods))

        # / diagonal products
        d2_prods = []
        for x in range(0, 16):
            for y in range(3, 20):
                d2_prods.append(matrix[y,x] * matrix[y-1, x+1] * matrix[y-2, x+2] * matrix[y-3, x+3])
        maxes.append(max(d2_prods))

        self.answer = (max(maxes))

Solution11().run()
