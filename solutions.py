# Project Euler solution implementations
import cProfile
import math


def sieve_of_eratosthenes(limit):
    # Uses Sieve of Eratosthenes to get a list of primes up to limit
    nums = set(range(2, int(round(limit, 0)) + 1))
    primes = []
    while nums:
        p = nums.pop()
        primes.append(p)
        print("Primes: {}".format(primes))
        remove = set([x for x in nums if x % p == 0])
        nums = nums.difference(remove)

    primes.sort()
    return primes


class Solution(object):
    def run(self, **kwargs):
        print("Running {}".format(self.__class__.__name__))
        cProfile.runctx('self.solve(**kwargs)', globals(), locals())
        print("The solution is {}".format(self.answer))

    def solve(self):
        raise NotImplemented


class Solution1(Solution):
    def solve(self, **kwargs):
        # If we list all the natural numbers below 10 that are multiples of 3 or 5,
        # we get 3, 5, 6 and 9. The sum of these multiples is 23.

        # Find the sum of all the multiples of 3 or 5 below 1000.
        mult = [3 * x for x in range(1, (1000 / 3) + 1)]
        mult.extend([5 * x for x in range(1, 1000 / 5)])
        nums = set(mult)
        self.answer = sum(nums)

#Solution1().run()


class Solution2(Solution):
    def solve(self, **kwargs):
        # Each new term in the Fibonacci sequence is generated by adding the previous two terms.
        # By starting with 1 and 2, the first 10 terms will be:

#            1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

        # By considering the terms in the Fibonacci sequence whose values do not exceed four million,
        # find the sum of the even-valued terms.
        limit = kwargs['limit']
        fib = [1, 2]
        while fib[len(fib) - 1] < limit:
            fib.append(fib[len(fib) - 1] + fib[len(fib) - 2])
        res = [x for x in fib if x % 2 == 0]
        self.answer = sum(res)

#Solution2().run(limit=4000000)


class Solution3(Solution):
    def get_prime_factors(self, num):
        # gets the prime factors for a numbers
        primes = sieve_of_eratosthenes(math.sqrt(num))
        res = [x for x in primes if num % x == 0]
        return res

    def solve(self, **kwargs):
        self.answer = max(self.get_prime_factors(600851475143))

Solution3().run()
